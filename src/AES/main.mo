


import Array "mo:base/Array";
import Debug "mo:base/Debug";
import Iter "mo:base/Iter";
import Int32 "mo:base/Int32";
import Nat32 "mo:base/Nat32";
import Nat8 "mo:base/Nat8";

actor {
  /************************************************************/
  let NB : Nat = 4;
  let NBb : Nat = 16;
  var key : [var Nat8] = Array.init<Nat8>(32, 0x00); // Nat8 == unsinged char
  var w : [var Nat32] = Array.init<Nat32>(60, 0);
  var data : [var Nat32] = Array.init<Nat32>(NB, 0);
  var nk : Int32 = 0; /* 4,6,8(128,192,256 bit) 鍵の長さ */
  var nr : Int32 = 0; /* 10,12,14 ラウンド数 */

  /************************************************************/

  func datadump(c : Text, dt : [var Int32], len : Int32) {
    Debug.print(c);
    for (i in Iter.range(0, Int32.toInt(len)*4)) {
      Debug.print(debug_show(dt[i]));
    };
    // for (d in dt.vals()) {
    //   Debug.print(debug_show(d));
    // };
    Debug.print("\n");
  };

  /************************************************************/
  /* FIPS 197  P.16 Figure 7 */
  let Sbox : [Nat8] = [ //Int32からNat8へ変更した。0xFFは1byte
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
  ];

  /************************************************************/
  /* FIPS 197  P.22 Figure 14 */
  let invSbox : [Nat32] = [
    0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
    0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
    0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
    0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
    0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
    0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
    0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
    0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
    0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
    0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
    0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
    0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
    0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
    0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
    0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
    0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
  ];

  /************************************************************/
  /* FIPS 197  P.19 Figure 10 */
  // 1byteごとの配列を4byteごと配列に変換しておく
  func AddRoundKey(data : [Nat32], n : Nat) : [Nat32] { //　w[i+NB*n]の型推論のためnはNatとする
    // int i;
    // for(i=0;i<NB;i++)
    // {
    //   data[i] ^= w[i+NB*n];
    // }
    Array.mapEntries<Nat32, Nat32>(data, func(_, i){w[i+NB*n]});
  };

  /************************************************************/
  /* FIPS 197  P.16 Figure 6 */
  func SubBytes(data :[Nat32]) : [Nat32] {
    // unsigned char *cb=(unsigned char*)data; // 4byteのint32を1byteごとにアクセスできるようにしている
    // for(i=0;i<NBb;i+=4)//理論的な意味から二重ループにしているが意味は無い
    // {
    //   for(j=0;j<4;j++)
    //   {
    //     cb[i+j] = Sbox[cb[i+j]];
    //   }
    // }

    // apply Sbox
    let sboxedData = Array.map<Nat8, Nat8>(to1ByteBase(data), func (val) {Sbox[Nat8.toNat(val)]});
    to4ByteBase(sboxedData);

    // // [Nat32,...]->[[Nat8,Nat8,Nat8,Nat8],...]
    // var nat8Array : [[Nat8]] = Array.map<Nat32, [Nat8]>(data, 
    //   func(nat32){
    //     Array.map<Nat8, Nat8>(Nat32ToNat8Array(nat32), 
    //       func(val){
    //         Sbox[Nat8.toNat(val)]// return Nat8
    //       });
    //   });
    // // [[Nat8,Nat8,Nat8,Nat8],...]->[Nat32,...]
    // Array.map<[Nat8], Nat32>(nat8Array, Nat8ArrayToNat32);
  };

  /************************************************************/
  /* FIPS 197  P.17 Figure 8 */
  func ShiftRows(data :[Nat32]) {
    // int i,j,i4;
    // unsigned char *cb=(unsigned char*)data;
    // unsigned char cw[NBb];
    // memcpy(cw,cb,sizeof(cw));
    // for(i=0;i<NB;i+=4)
    // {
    //   i4 = i*4;
    //   for(j=1;j<4;j++)
    //   {
    //     cw[i4+j+0*4] = cb[i4+j+((j+0)&3)*4];
    //     cw[i4+j+1*4] = cb[i4+j+((j+1)&3)*4];
    //     cw[i4+j+2*4] = cb[i4+j+((j+2)&3)*4];
    //     cw[i4+j+3*4] = cb[i4+j+((j+3)&3)*4];
    //   }
    // }
    // memcpy(cb,cw,sizeof(cw));
    // let cb : [Nat8] = 
    // var cw : [var Nat8] = Array.tabulateVar<Nat8>(NBb, )

    // for(i=0;i<NB;i+=4)
    // {
    //   i4 = i*4;
    //   for(j=1;j<4;j++)
    //   {
    //     cw[i4+j+0*4] = cb[i4+j+((j+0)&3)*4];
    //     cw[i4+j+1*4] = cb[i4+j+((j+1)&3)*4];
    //     cw[i4+j+2*4] = cb[i4+j+((j+2)&3)*4];
    //     cw[i4+j+3*4] = cb[i4+j+((j+3)&3)*4];
    //   }
    // }

    /*
    flattenで[Nat8]にした後に、元に戻す
    4個ごとにまとめる。
    */

  };










  /************************************************************/ 
  func to1ByteBase(nat32Array : [Nat32]) : [Nat8] {
    // [Nat32,...]->[Nat8,Nat8,Nat8,Nat8,...]
    Array.flatten<Nat8>(
      Array.map<Nat32,[Nat8]>(nat32Array, Nat32ToNat8Array)
    );
    // Array.flatten<Nat8>(Array.map<Nat32, [Nat8]>(nat32Array, func(nat32){
    //   Array.map<Nat8, Nat8>(Nat32ToNat8Array(nat32), func(val){
    //       Sbox[Nat8.toNat(val)]// return Nat8
    //     });
    //   }));
  };
  func to4ByteBase(nat8Array : [Nat8]) : [Nat32] {
    // 4個ごとに折り畳んで、それらをNat32にする
    Array.map<[Nat8], Nat32>(fold4Nat8Array(nat8Array), Nat8ArrayToNat32);
  };
  func Nat32ToNat8Array(nat32 : Nat32) : [Nat8] {
    let a : Nat8 = Nat8.fromNat( Nat32.toNat((nat32 >> 24) & 0xFF));
    let b : Nat8 = Nat8.fromNat( Nat32.toNat((nat32 >> 16) & 0xFF));
    let c : Nat8 = Nat8.fromNat( Nat32.toNat((nat32 >>  8) & 0xFF));
    let d : Nat8 = Nat8.fromNat( Nat32.toNat((nat32 >>  0) & 0xFF));
    [a,b,c,d]
  };
  func Nat8ArrayToNat32(nat8Array : [Nat8]) : Nat32 {
    // Nat8->Nat->Nat32
    let a = Nat32.fromNat((Nat8.toNat(nat8Array[0]))) << 24; 
    let b = Nat32.fromNat((Nat8.toNat(nat8Array[1]))) << 16; 
    let c = Nat32.fromNat((Nat8.toNat(nat8Array[2]))) <<  8; 
    let d = Nat32.fromNat((Nat8.toNat(nat8Array[3]))) <<  0; 
    a | b | c | d
  };
  func flattenNat8ArrayArray(nat8ArrayArray : [[Nat8]]) : [Nat8] {
    Array.flatten(nat8ArrayArray);
  };
  func fold4Nat8Array(nat8Array : [Nat8]) : [[Nat8]] {
    var i = 0;
    Array.mapFilter<Nat8,[Nat8]>(nat8Array, func(_) : ?[Nat8] {
      let op = if (i%4 == 0) ?[nat8Array[i],nat8Array[i+1],nat8Array[i+2],nat8Array[i+3]]
      else null;
      i += 1;
      op
    });
  };


};


/*
data [Int32] size 16 には、init(usinged char)が16個分入っている
unsigned char *cb=(unsigned char*)data; で　unsigned charにキャストする

1バイトのcharを、int32の配列に変換して、それを1byteで解釈する

4byteのInt32を　1byteのNat32 x 4に解釈する方法。

Int32%(256^4), Int32%(256^3), Int32%(256^2), Int32%(256^1)

10,000,000,000

リトルエンディアンと符号付きの話、

Int32ではなく、Nat32の方がいいかも。usinged charをmemcopyしているから、実質Nat8の配列と同じ。

ということは、初めからNat8で型をとった方がいい。

*/




